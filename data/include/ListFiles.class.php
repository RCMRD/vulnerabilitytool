<?php
require_once("SessionStarter.php");
require_once ('../../Config.php');
include('../include/Misc.class.php');
/**
* ListFiles lists all zip files in a the downloads directory under ad selected component folder. 
*/
class ListFiles
{
	public function selectComponentFiles ($level, $component)
    {
        $format = new Format();
        if (file_exists("../../data/downloads/".$level ."/".$component."/")) {
            $attributes = [];
            foreach (new DirectoryIterator("../../data/downloads/" . $level . "/" . $component . "/") as $folderInfo) {
                if (!$folderInfo->isDot() && $folderInfo->isFile()) {
                    $attributes[] = array(
                        'name' => str_replace('_', ' ', substr($folderInfo->getFilename(), 0, -8)),
                        'size' => $format->formatBytes($folderInfo->getSize() ),
                        'format' => $folderInfo->getExtension(),
                        'link' => '<a class="download_button" href="' . substr($folderInfo->getPath(), 6) . '/' .
                            $folderInfo->getFilename() . '" download>Download</a>'
                    );
                }
            }
            header('Content-type: application/json', true);
            //output of the data in json
            echo json_encode($attributes, JSON_UNESCAPED_SLASHES);
        }
    }
    public function findNames($filename) {
        $nameArry = explode('_', $filename);
        $leftCut = strlen($nameArry[0]) + strlen($nameArry[1]) + 2;
        if (strpos($filename, "shp")!== false || strpos($filename, "tif")!== false){
            return substr($filename,$leftCut, -8);
        }
        else if (strpos($filename, "Atlas")){
            return substr($filename, 0, -4);
        }
        else {
            return substr($filename, $leftCut, -4);
        }
    }
    public function findExtension($filename){
        if (strpos($filename, "shp")!== false){
            return "shp";
        }
        else if (strpos($filename, "tif")!== false){
            return "tif";
        }
        else{
            return pathinfo($filename, PATHINFO_EXTENSION);
        }
    }

    public function original_export($level){
        if (file_exists("../../data/downloads/".$level."/")) {
            $format = new Format();
            $files = [];
            //If the path sessionid, name it custom.
            foreach (new RecursiveIteratorIterator(new RecursiveDirectoryIterator("../../data/downloads/" . $level . "/",
                RecursiveDirectoryIterator::SKIP_DOTS)) as $filename) {
                if (basename($filename->getPath()) == 'v' . session_id()) {
                    $files[] = array(
                        'name' => str_replace('_', ' ', $this->findNames($filename->getFilename())),
                        'component' => 'Custom Vulnerability',
                        'size' =>  $format->formatBytes($filename->getSize() ),
                        'format' => $this->findExtension($filename->getFilename()),
                        'link' => '<a class="download_button" href="' . substr($filename->getPath(), 6) . '/' .
                            $filename->getFilename() . '" download>Download</a>'
                    );
                } //Exclude folders other than the vulnerability and the 3 components.
                else if ((in_array(basename($filename->getPath()), array("atlas", "vulnerability", "exposure",
                    "sensitivity", "lack_of_adaptive_capacity")))) {
                    $files[] = array(
                        'name' => str_replace('_', ' ', $this->findNames($filename->getFilename())),
                        'component' => str_replace('_', ' ', ucwords(basename($filename->getPath()))),
                        'size' => $format->formatBytes($filename->getSize() ),
                        'format' => $this->findExtension($filename->getFilename()),
                        'link' => '<a class="download_button" href="' . substr($filename->getPath(), 6) . '/' .
                            $filename->getFilename() . '" download>Download</a>'
                    );
                } else {
                    echo "";
                }

            }
           // header('Content-type: application/json', true);
            //output of the data in json
            return $files;

        }

    }
}

/**
 * Class WebExports generates wms and wfs files export links.
 */

class WebExports
{
    public $shp = "SHAPE-ZIP";
    public $kml = "application/vnd.google-earth.kml+xml";
    public $geojson = "application/json";
    public $csv = "csv";
    public $gml = "application/gml+xml;%20version=3.2";
    public $geotiff = "image%2Fgeotiff";
    public $kmz = "application%2Fvnd.google-earth.kmz+xml";
    public $kmlWMS = "application%2Fvnd.google-earth.kml%2Bxml";
    public $pdf = "application%2Fpdf";
    public $png = "image%2Fpng";
    public $jsonArray = [];
    /*
     * generates download links from existing layers array of the map.
     */
    public function webExport($workspace, $layers, $components, $numberOfFeatures, $height, $width, $bbox)
    {
        $config = new Config();

        foreach ($layers as $index => $layer) {

            $fullName = explode("_", $layer);
            $sizeOfRemoveNames= strlen($fullName[0]."_". $fullName[1]);
            //Prevent custom vulnerability layer name from trimmed to have same name as shp files.
            if ( $fullName[0] !== "malawi") { //If the name has session names
                $Name = 'custom_vulnerability_'.substr($layer, $sizeOfRemoveNames+1);
            }
            else {
                $Name = substr($layer, $sizeOfRemoveNames+1);
            }
            $FinalName = str_replace('_', ' ', $Name);

            $geoserverWFS =  $config->geoserverUrl. "/" . $workspace . "/ows?service=WFS&version=1.0.0&request=GetFeature";
            $geoserverWMS =  $config->geoserverUrl. "/" . $workspace . "/wms?service=WMS&version=1.1.0&request=GetMap";
            $WMSLayerName = "&layers=" . $workspace . ':' . $layer;
            $WFSLayerName = "&typeName=" . $workspace . ':' . $layer;
            $WFSMaxFeatures = "&maxFeatures=" . $numberOfFeatures;
            $WMSBBox = "&bbox=".$bbox;
            $WMSWidth = "&width=" . $width;
            $WMSHeight = "&height=" . $height;
            $WMSSRS = "&srs=EPSG:4326";

            //$WFSFormats = ["shp" => "SHAPE-ZIP", "kml" => "application/vnd.google-earth.kml+xml", "gml" => "application/gml+xml;%20version=3.2", "geojson" => "application/json", "csv" => "csv"];
            $WMSFormats = ["pdf" => "application%2Fpdf", "png" => "image%2Fpng", "kml"=>"application%2Fvnd.google-earth.kml%2Bxml",
                "kmz" => "application%2Fvnd.google-earth.kmz+xml"];
                //Generate link for all WMS formats
                foreach ($WMSFormats as $key => $value) {
                    $WMSLinks = $geoserverWMS . $WMSLayerName . $WMSBBox .  $WMSHeight . $WMSWidth. $WMSSRS . "&format=" . $value;
                    $this->jsonArray[] = array(
                        'name' => $FinalName,
                        'component' => $components[$index],
                        'format' => $key,
                        'size' => "",
                        'link' => '<a class="download_button" href=' . $WMSLinks . ' download>Download</a>'
                    );
                }
        }
        return $this->jsonArray;

    }
}
?>